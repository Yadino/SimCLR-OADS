"""Load and plot linear regression results (generated by eeg_lin_reg)"""

import os
import datetime
import numpy as np
import pickle
import matplotlib.pyplot as plt

output_dir = r"D:\01 Files\04 University\00 Internships and theses\2. AI internship\EEG data\outputs"
# Info identifying the arch, checkpoint, version of code and whatever
#run_dir = "2024-02-14_00-05-43 - v1 resnet50 ch1100"
run_dir = "2024-02-13_18-10-50 - v1 resnet18 ch200"

# If needed
additional_title_info = ""

# Merge them
output_dir = os.path.join(output_dir, run_dir)

downsampling_factor = 4

# List of selected subjects
selected_subjects = [9] #range(5,36)

# For resnet50 (for now)
#selected_layers = ["layer4", "fc2"]

# For resnet18
selected_layers = ["layer2", "layer3", "layer4", "fc2"]

# List
selected_channels = ['Iz', 'Oz', 'POz', 'P3', 'P4']

original_sampling_rate = 1024

# EEG channels by name (const)
channel_order = ['Fp1', 'AF7', 'AF3', 'F1', 'F3', 'F5', 'F7', 'FT7', 'FC5', 'FC3', 'FC1', 'C1', 'C3', 'C5', 'T7', 'TP7', 'CP5', 'CP3', 'CP1', 'P1', 'P3', 'P5', 'P7', 'P9', 'PO7', 'PO3', 'O1', 'Iz', 'Oz', 'POz', 'Pz', 'CPz', 'Fpz', 'Fp2', 'AF8', 'AF4', 'AFz', 'Fz', 'F2', 'F4', 'F6', 'F8', 'FT8', 'FC6', 'FC4', 'FC2', 'FCz', 'Cz', 'C2', 'C4', 'C6', 'T8', 'TP8', 'CP6', 'CP4', 'CP2', 'P2', 'P4', 'P6', 'P8', 'P10', 'PO8', 'PO4', 'O2', 'left', 'right', 'above', 'below']

# A subset of channels that are visual system related
################################ Define util funcs

# Get indexes of the selected channels
selected_channel_indexes = [channel_order.index(channel) for channel in selected_channels]


def plot_rs(data, labell="", ylabel="", title="", downsampling_factor=downsampling_factor):
    """Plot either an r2 or an r graph with a -100 to 400ms timeline"""

    # Length of the downsampled data
    downsampled_num_points = len(data)

    # Calculate original number of points
    original_num_points = downsampled_num_points * downsampling_factor

    # Calculate the corresponding time range
    time_range_seconds = original_num_points / original_sampling_rate  # Duration of original data in seconds
    time_range_ms = time_range_seconds * 1000  # Convert duration to milliseconds
    time_start_ms = -100  # Start time in milliseconds
    time_end_ms = time_start_ms + time_range_ms  # End time in milliseconds

    # Create time axis
    time_axis = np.linspace(time_start_ms, time_end_ms, downsampled_num_points)

    # Plot the graph
    plt.plot(time_axis, data, label=labell)
    plt.xlabel('Time (ms)')
    plt.ylabel(ylabel)
    plt.title(title)
    plt.axvline(x=0, color='r', linestyle='--')  # Add a dashed vertical line at time = 0ms
    plt.grid(True)
    #plt.show()


def plot_channel(channel_data):
    """Do stuff with multiple channels on one layer and one subject"""
    pass


def plot_layer(layer_info, layer_name, sub):
    """Do stuff with multiple channels on one layer and one subject"""

    # Plot R2
    plot_title = f"{run_dir} {additional_title_info} subject {sub} {layer_name}  TEST $R^2$"
    # Plot multiple lines in one thingy
    for channel, data in layer_info.items():
        plot_rs(data["test_r2s"], labell=channel, ylabel=f'$R^2$', title=plot_title)
    plt.legend(loc='best')
    plt.show()

    # Plot correlations
    plot_title = f"{run_dir} {additional_title_info} subject {sub} {layer_name} TEST CORRELATIONS"
    # Plot multiple lines in one thingy
    for channel, data in layer_info.items():
        plot_rs(data["test_rs"], labell=channel, ylabel=f'Pearsonâ€›s  r', title=plot_title)
    plt.legend(loc='best')
    plt.show()


def plot_subject(subject_info):
    """Do stuff on multiple layers and channels on one subject"""
    pass


def plot_whatever(all_info):
    """Get all the data and do whatever u want"""
    pass

#%%

all_info = {}

# Loop over all data and load everything
for sub in selected_subjects:
    # Make dir
    subject_dir = os.path.join(output_dir, f"sub_{sub}")

    subject_info = {}

    for layer_name in selected_layers:
        # Get dir
        layer_dir = os.path.join(subject_dir, layer_name)

        # Dicts for all channels

        layer_info = {}

        for channel in selected_channels:
            # channel_name = channel_order[channel]
            # Get dir
            channel_dir = os.path.join(layer_dir, channel)

            # Load data
            train_rs = np.load(os.path.join(channel_dir, "train_rs.npy"))
            train_r2s = np.load(os.path.join(channel_dir, "train_r2s.npy"))
            train_betas = np.load(os.path.join(channel_dir, "train_betas.npy"))
            # train_lin_regs = np.load(os.path.join(channel_dir, "train_lin_regs.npy"))
            test_rs = np.load(os.path.join(channel_dir, "test_rs.npy"))
            test_r2s = np.load(os.path.join(channel_dir, "test_r2s.npy"))
            test_betas = np.load(os.path.join(channel_dir, "test_betas.npy"))

            channel_data = {
                'train_rs': train_rs,
                'train_r2s': train_r2s,
                'train_betas': train_betas,
                # 'train_lin_regs': train_lin_regs,
                'test_rs': test_rs,
                'test_r2s': test_r2s,
                'test_betas': test_betas
            }

            layer_info[channel] = channel_data

        plot_layer(layer_info, layer_name, sub)
        subject_info[layer_name] = layer_info
    # plot_subject(subject_info)
    all_info[sub] = subject_info
plot_whatever(all_info)
